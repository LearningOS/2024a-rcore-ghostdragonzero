# 一、实现的功能
## 1代码位置修改
修改TaskInfo结构体到Task.rs目录
并在TCB结构体内添加了task_start_time来记录task的开始时间
本来是想在TaskInfo内改动但是也需要改动对应user目录下的lib.rs的TaskInfo
*在实验的时候发现内核的TaskInfo与User的TaskInfo不一致也不会报错 但是结果会因为结构体分布的原因变得很奇怪*
## 2功能实现
### 2.1记录调用次数
在syscall()函数中添加了add_syscall_time(syscall_id) 通过每次调用的syscall_id来记录次数  觉得分散在各个调用并不好用  因为需要获取当前进程而有些调用并没有做获取当前进程的操作
### 2.2记录程序运行时间
这个我选择添加一个start_time来记录程序最初运行时间  通过每次获取info的时候获取一次当前时间计算总的运行时间 我认为这个start_time应该放在TaskInfo结构体内 

# 二问题简答
## 1 使用特权指令出错

## 2、深入理解trap.S
### 2.1
在__alltraps中我们会将sp指向内核栈并将这个值保存到a0寄存器中
__restore的时候a0保存的就是内核栈之中并通过将这个值给sp获取内核栈中保存的之前存储的寄存器数据
__restore会在两个地方被用到
①在trap的处理结束时返回会需要__restore复原之前的执行状态
②系统初始话完成后需要进入U特权模式时会用到
### 2.2
特殊处理了t0、t1、t2寄存器
t0保存的sstatus记录trap发生前的特权等级
t1保存的sepc记录trap发生前最后的pc指针
t2保存的sscratch指向内核栈
### 2.3
x2对应的是sp指针在L9就把之前x2的数据
保存到sscratch中所以不保存
x4是默认没有使用的寄存器我们没有特殊使用就没有去保存
### 2.4
sp 重新指向用户栈栈顶，sscratch 也依然保存 进入 Trap 之前的状态并指向内核栈栈顶
### 2.5
在__restore中通过sret让系统进入U特权
### 2.6
sp 指向内核栈顶, sscratch指向用户栈顶
### 2.7
当app调用syscall时候触发中断就会从U模式进入S模式

# 三荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：


2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：


3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

